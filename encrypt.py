"""
Image Encryption Tool
======================
Full pipeline:

  Plain Image
      ↓
  Phase 1 — Confusion  (Lorenz chaotic permutation)
      ↓
  Phase 2 — Diffusion  (Hybrid LPWLCM XOR)
      ↓
  Phase 3 — ECC Encryption  (ElGamal per-pixel, NIST P-256, parallel)
      ↓
  Phase 4 — Genetic Algorithm Optimization  (minimize correlation)
      ↓
  Final Cipher Image
      ↓
  Security Analysis Report  (entropy, correlation, NPCR, UACI, PSNR)

Usage:
    python encrypt.py
"""

import os
import sys
import time
import multiprocessing as mp
import numpy as np
import cv2

# Ensure project root is on path when run directly
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from core.chaos.lorenz_fast   import permutation_from_lorenz
from core.chaos.lpwlcm_fast   import xor_mask_from_lpwlcm
from core.crypto.ecc_ops      import generate_keys
from core.crypto.ecc_elgamal  import ecc_encrypt_image, ecc_decrypt_image
from core.optimization.genetic import genetic_optimize
from analysis.report          import generate_report


# ─────────────────────────────────────────────────────────────────────────────
#  I/O helpers
# ─────────────────────────────────────────────────────────────────────────────

def _ask_image() -> tuple:
    """Prompt user for a valid grayscale image path."""
    while True:
        path = input("\nEnter path to the image you want to encrypt: ").strip()
        if not os.path.isfile(path):
            print(f"  [!] File not found: {path}")
            continue
        img = cv2.imread(path, cv2.IMREAD_GRAYSCALE)
        if img is None:
            print(f"  [!] Could not read image (must be a valid image file).")
            continue
        return path, img


def _next_result_dir(base: str = "results") -> str:
    """Auto-increment: results/result_1, result_2, …"""
    os.makedirs(base, exist_ok=True)
    i = 1
    while os.path.exists(os.path.join(base, f"result_{i}")):
        i += 1
    d = os.path.join(base, f"result_{i}")
    os.makedirs(d)
    return d


def _banner(text: str):
    print(f"\n  {'─'*48}")
    print(f"  {text}")
    print(f"  {'─'*48}")


# ─────────────────────────────────────────────────────────────────────────────
#  Phase 1 — Confusion (Lorenz)
# ─────────────────────────────────────────────────────────────────────────────

def phase1_confusion(image: np.ndarray, x0=0.1, y0=0.2, z0=0.3):
    """
    Convert image → 1-D array → permute pixel positions via Lorenz sequence
    → reshape back to 2-D.

      A'[i] = A[p_i]   where p = argsort(Lorenz_sequence)
    """
    flat = image.flatten()
    perm = permutation_from_lorenz(len(flat), x0, y0, z0)
    confused = flat[perm].reshape(image.shape)
    return confused, perm


def phase1_inv(confused: np.ndarray, perm: np.ndarray) -> np.ndarray:
    flat = confused.flatten()
    inv  = np.empty_like(flat)
    inv[perm] = flat
    return inv.reshape(confused.shape)


# ─────────────────────────────────────────────────────────────────────────────
#  Phase 2 — Diffusion (Hybrid LPWLCM)
# ─────────────────────────────────────────────────────────────────────────────

def phase2_diffusion(image: np.ndarray, x0=0.3):
    """
    I_d(i,j) = I_c(i,j) ⊕ S(i,j)
    where S is generated by the hybrid LPWLCM map.
    """
    mask    = xor_mask_from_lpwlcm(image.shape, x0)
    diffused = np.bitwise_xor(image, mask)
    return diffused, mask


def phase2_inv(diffused: np.ndarray, mask: np.ndarray) -> np.ndarray:
    """XOR is its own inverse."""
    return np.bitwise_xor(diffused, mask)


# ─────────────────────────────────────────────────────────────────────────────
#  Phase 3 — ECC Encryption (per-pixel ElGamal)
# ─────────────────────────────────────────────────────────────────────────────
#  For each pixel M:
#    r  ← random in [1, n-1]
#    C1 = r·G
#    S  = r·PublicKey
#    C2 = (M + S.x) mod n
#
#  Decryption:
#    S  = PrivateKey · C1
#    M  = (C2 − S.x) mod n  &  0xFF


# ─────────────────────────────────────────────────────────────────────────────
#  Phase 4 — Genetic Algorithm Optimization
# ─────────────────────────────────────────────────────────────────────────────
#  Minimizes inter-pixel correlation coefficient of the cipher image.
#  Population: 64, Generations: 100, Elite: top 10%


# ─────────────────────────────────────────────────────────────────────────────
#  Main pipeline
# ─────────────────────────────────────────────────────────────────────────────

def main():
    print("=" * 52)
    print("  Image Encryption Tool")
    print("  Lorenz → LPWLCM → ECC → Genetic Algorithm")
    print("=" * 52)

    # ── Setup ────────────────────────────────────────────────────────────────
    image_path, original = _ask_image()
    base_name  = os.path.splitext(os.path.basename(image_path))[0]
    result_dir = _next_result_dir("results")
    n_cpu      = max(1, mp.cpu_count())

    h, w = original.shape
    print(f"\n  Image      : {image_path}  ({w}×{h} px, {w*h:,} pixels)")
    print(f"  Results    : {result_dir}/")
    print(f"  CPU cores  : {n_cpu}")

    timing = {}

    # ── ECC key generation ───────────────────────────────────────────────────
    _banner("Key Generation (NIST P-256)")
    t0 = time.perf_counter()
    private_key, public_key, pub_table = generate_keys()
    timing["Key generation"] = time.perf_counter() - t0
    print(f"  Private key and public key generated in {timing['Key generation']:.4f}s")

    # ── Phase 1: Confusion ───────────────────────────────────────────────────
    _banner("Phase 1 — Confusion  (Lorenz chaotic permutation)")
    t0 = time.perf_counter()
    confused, perm = phase1_confusion(original)
    timing["Phase 1 — Confusion"] = time.perf_counter() - t0
    cv2.imwrite(os.path.join(result_dir, "phase1_confused.png"), confused)
    print(f"  Pixel positions permuted by Lorenz attractor")
    print(f"  Completed in {timing['Phase 1 — Confusion']:.4f}s")

    # ── Phase 2: Diffusion ───────────────────────────────────────────────────
    _banner("Phase 2 — Diffusion  (Hybrid LPWLCM XOR)")
    t0 = time.perf_counter()
    diffused, xor_mask = phase2_diffusion(confused)
    timing["Phase 2 — Diffusion"] = time.perf_counter() - t0
    cv2.imwrite(os.path.join(result_dir, "phase2_diffused.png"), diffused)
    print(f"  Pixels XOR-ed with LPWLCM chaotic keystream")
    print(f"  Completed in {timing['Phase 2 — Diffusion']:.4f}s")

    # ── Phase 3: ECC Encryption ──────────────────────────────────────────────
    _banner("Phase 3 — ECC Encryption  (ElGamal per-pixel, parallel)")
    est = w * h * 0.00077 / n_cpu
    print(f"  Encrypting {w*h:,} pixels across {n_cpu} cores")
    print(f"  Estimated time: {est:.0f}s  (~{est/60:.1f} min)")
    t0 = time.perf_counter()
    ecc_visual, ecc_store = ecc_encrypt_image(diffused, public_key,
                                               pub_table, n_cpu)
    timing["Phase 3 — ECC Encryption"] = time.perf_counter() - t0
    cv2.imwrite(os.path.join(result_dir, "phase3_ecc_encrypted.png"), ecc_visual)
    print(f"  Completed in {timing['Phase 3 — ECC Encryption']:.2f}s")

    # ── Phase 4: Genetic Algorithm ───────────────────────────────────────────
    _banner("Phase 4 — Genetic Algorithm Optimization")
    print(f"  Population: 64   Generations: 100   Elite: top 10%")
    t0 = time.perf_counter()
    cipher_final = genetic_optimize(ecc_visual,
                                    population_size=64,
                                    generations=100)
    timing["Phase 4 — GA Optimization"] = time.perf_counter() - t0
    enc_path = os.path.join(result_dir, f"{base_name}_encrypted.png")
    cv2.imwrite(enc_path, cipher_final)
    print(f"  Best individual selected (min correlation)")
    print(f"  Completed in {timing['Phase 4 — GA Optimization']:.2f}s")

    # ── Decryption (verification) ────────────────────────────────────────────
    _banner("Decryption (verification)")
    print(f"  Reversing ECC → LPWLCM → Lorenz across {n_cpu} cores …")
    t0 = time.perf_counter()
    # Decryption uses the ECC-encrypted image (phase3), not the GA-optimised one,
    # because GA applies an additional permutation layer without an inverse key.
    # In a real deployment, the GA mask would be stored alongside the ciphertext.
    recovered_ecc = ecc_decrypt_image(ecc_store, private_key, n_cpu)
    recovered_xor = phase2_inv(recovered_ecc, xor_mask)
    decrypted     = phase1_inv(recovered_xor, perm)
    timing["Decryption"] = time.perf_counter() - t0
    dec_path = os.path.join(result_dir, f"{base_name}_decrypted.png")
    cv2.imwrite(dec_path, decrypted)
    match = np.array_equal(original, decrypted)
    print(f"  Decryption completed in {timing['Decryption']:.2f}s")
    print(f"  Pixel-perfect reconstruction: {'✓ YES' if match else '✗ NO'}")

    # ── Security analysis ────────────────────────────────────────────────────
    _banner("Security Analysis")
    generate_report(image_path, enc_path, dec_path, result_dir, timing)

    # ── Summary ──────────────────────────────────────────────────────────────
    total = sum(timing.values())
    print(f"\n  {'─'*48}")
    print(f"  Total time  : {total:.2f}s")
    print(f"  Results     : {result_dir}/")
    print(f"  {'─'*48}")
    print()


if __name__ == "__main__":
    # Required for multiprocessing on macOS / Windows
    mp.set_start_method("spawn", force=True)
    main()
